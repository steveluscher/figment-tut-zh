# ä»‹ç»

> åŸæ–‡ï¼š<https://github.com/figment-networks/learn-tutorials/blob/master/thegraph/explore-an-existing-subgraph.md>

åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæ‚¨å°†å­¦ä¹ å¦‚ä½•åˆ©ç”¨ä¸€äº›ç°æœ‰çš„å›¾åè®®å­å›¾æ¥åˆ›å»ºä¸€ä¸ªç®€å•çš„ React åº”ç”¨ç¨‹åºã€‚å®ƒåŒ…æ‹¬é…ç½® GraphQL æŸ¥è¯¢ï¼Œå¹¶è§£é‡Šå¦‚ä½•ä½¿ç”¨é¥¼å›¾æ‰§è¡Œç®€å•çš„æ•°æ®å¯è§†åŒ–ã€‚

# å…ˆå†³æ¡ä»¶

ä¸ºäº†å®Œæˆæœ¬æ•™ç¨‹ï¼Œæ‚¨éœ€è¦äº†è§£ä¸€äº›å…³äº NodeJSã€ECharts åº“å’Œ GraphQL æŸ¥è¯¢çš„åŸºç¡€çŸ¥è¯†ã€‚æ­¤å¤–ï¼Œç†Ÿæ‚‰ç°æœ‰çš„å­å›¾æ¨¡å¼å’Œå›¾å½¢æµè§ˆå™¨ä¼šéå¸¸æœ‰å¸®åŠ©ã€‚

åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæ‚¨å°†ä¸`Hopr on Mainnet`å­å›¾è¿›è¡Œäº¤äº’ã€‚ä½ å¯ä»¥åˆ©ç”¨è¿™ä¸ª[æ¸¸ä¹åœº](https://thegraph.com/explorer/subgraph?id=0x77d63a93c90a9860ab07ee6bc7bc5becad1cbfde-0&view=Playground)å»æ¢ç´¢ä¸€ä¸‹ã€‚

# è¦æ±‚

ä½ éœ€è¦åœ¨ä½ çš„æœºå™¨ä¸Šå®‰è£…`Node.js >= 14.0.0`å’Œ`npm >= 5.6`ã€‚

# é¡¹ç›®è®¾ç½®

è¿è¡Œä»¥ä¸‹å‘½ä»¤åˆ›å»ºä¸€ä¸ªæ–°é¡¹ç›®ã€‚

```
npx create-react-app my-app
cd my-app 
```

æ­¤å¤–ï¼Œæ‚¨éœ€è¦å®‰è£…å¿…è¦çš„è½¯ä»¶åŒ…ï¼ŒåŒ…æ‹¬è¯·æ±‚å®¢æˆ·ç«¯ã€GraphQL æ”¯æŒå’Œç”¨äºå¯è§†åŒ–çš„ EChartsã€‚

```
npm i @apollo/client graphql echarts-for-react echarts 
```

åœ¨æœ¬åœ°ä¸»æœºä¸Šè¿è¡Œåº”ç”¨ç¨‹åºã€‚

```
npm start 
```

æ‚¨åº”è¯¥ä¼šåœ¨ç»ˆç«¯ä¸­çœ‹åˆ°ç±»ä¼¼çš„æ¶ˆæ¯ã€‚

```
Compiled successfully!

You can now view my-app in the browser.

  Local:            http://localhost:3000
  On Your Network:  http://192.168.0.145:3000

Note that the development build is not optimized.
To create a production build, use yarn build. 
```

ç„¶åï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œæ‚¨å¯ä»¥åœ¨ [http://localhost:3000](http://localhost:3000) çœ‹åˆ°æ‚¨çš„é¡¹ç›®ã€‚

# åˆ›å»ºæŸ¥è¯¢å®¢æˆ·ç«¯

åœ¨`src`æ–‡ä»¶å¤¹ä¸‹åˆ›å»ºä¸€ä¸ªåä¸º`QueryClients.js`çš„æ–°æ–‡ä»¶ã€‚æ·»åŠ ä»¥ä¸‹è„šæœ¬æ¥é…ç½®ä¸€ä¸ªæŸ¥è¯¢å®¢æˆ·ç«¯ï¼Œä»¥ä¾¿ä¸ [HOPR å­å›¾ Mainnet](https://thegraph.com/legacy-explorer/subgraph/minatofund/hopr-subgraph-mainnet) è¿›è¡Œäº¤äº’ã€‚æ‚¨éœ€è¦è¿™ä¸ªå®¢æˆ·æœºå‘å­å›¾ç«¯ç‚¹å‘é€ GraphQL æŸ¥è¯¢ã€‚

```
import { ApolloClient, InMemoryCache, gql } from '@apollo/client'

export const hoprClient = new ApolloClient({
    uri: 'https://api.thegraph.com/subgraphs/name/minatofund/hopr-subgraph-mainnet',
    cache: new InMemoryCache()
  })
```

# é…ç½®æŸ¥è¯¢å’Œå¯è§†åŒ–

åœ¨`src`æ–‡ä»¶å¤¹ä¸‹åˆ›å»ºæ–‡ä»¶`HolderBalance.js`ã€‚æ·»åŠ ä»¥ä¸‹ä»£ç :

```
import React from 'react'
import ReactECharts from 'echarts-for-react'
import { gql } from '@apollo/client'
import {hoprClient} from './QueryClients'

class HolderBalance extends React.Component {
  state = {
    loading: true,
    holderBalance: []
  }

  async fetchData() {
    const holderBalanceQuery = `
 query accounts($skip: Int!) {
 accounts(where:{HoprBalance_gt:0, id_not:"0x0000000000000000000000000000000000000000"},first:1000, skip:$skip, orderBy: HoprBalance, orderDirection: desc)
 {
 totalBalance
 }
 }
 `

    try {
      let skip = 0
      let allResults = []
      let found = false
      while (!found) {
        let result = await hoprClient.query({
          query: gql(holderBalanceQuery),
          variables: {
            skip: skip
          },
          fetchPolicy: 'cache-first',
        })
        allResults = allResults.concat(result.data.accounts)
        if (result.data.accounts.length < 1000) {
          found = true
        } else {
          skip += 1000
        }
      }

      return allResults
    } catch (e) {
      console.error(e)
    }
  }

  componentDidMount() {
    this.fetchData().then(data => {
      this.processHolderBalanceData(data)
    }).catch(e => {
      console.error(e)
    })
  }

  processHolderBalanceData(data) {
    // Sizes are sorted in descending order
    const sizes = data.map(item => (parseFloat(item.totalBalance)))
    const spliters = [10, 100, 1000, 10000, 100000]
    // Find indexes spliting the sizes by given spliters
    let spliterIndex = spliters.length - 1
    let splitingIndexes = [0]
    for (let [idx, size] of sizes.entries()) {
      while (size <= spliters[spliterIndex]) {
        splitingIndexes.push(idx)
        spliterIndex -= 1
      }
      if (spliterIndex < 0 )
        break
    }
    // Split sizes, get chunk size and calculate sum of each chunk
    const chunkNames = ['>100k ğŸ³', '10k-100k', '1k-10k', '100-1k', '10-100', '0-10']
    let splited = []
    for (let i = 0; i < splitingIndexes.length - 1; i++) {
      const chunk = sizes.slice(splitingIndexes[i], splitingIndexes[i + 1])
      splited.push({
        name: chunkNames[i],
        chunk: chunk
      })
    }
    splited.push({
      name: chunkNames[splitingIndexes.length - 1],
      chunk: sizes.slice(splitingIndexes[splitingIndexes.length - 1])
    })
    // Update holder balance data
    const reducer = (accumulator, currentValue) => accumulator + currentValue
    let holderBalance = splited.map((item) => {
      const length = item.chunk.length
      const noun = length === 1 ? 'holder' : 'holders'
      return ({
        name: `${item.name} (${length} ${noun})`,
        value: item.chunk.reduce(reducer)
      })
    })
    this.setState({
      loading: false,
      holderBalance: holderBalance
    })
  }

  chart() {
    if (this.state.loading) {
      return <p>Loading...</p>
    }
    const options = {
      tooltip: {
          trigger: 'item',
          formatter: '{a} <br/>{b} : {c} ({d}%)'
      },
      series: [
        {
          name: 'Holder Balance',
          type: 'pie',
          radius: '50%',
          emphasis: {
            itemStyle: {
              shadowBlur: 10,
              shadowOffsetX: 0,
              shadowColor: 'rgba(0, 0, 0, 0.5)'
            }
          },
          data: this.state.holderBalance.map((item) => {
            return {
              ...item,
              value: parseFloat(item.value.toFixed(2))
            }
          }),
        }
      ]
    }
    return <ReactECharts option={options} />;
  }

  render() {
    return (
      <div>
        {this.chart()}
      </div>
    )
  }
}

export default HolderBalance
```

è®©æˆ‘è§£é‡Šä¸€ä¸‹ä»£ç æ¯ä¸ªéƒ¨åˆ†çš„åŠŸèƒ½ã€‚

å¯¼å…¥å¿…è¦çš„ç»„ä»¶ã€‚

```
import React from 'react'
import ReactECharts from 'echarts-for-react'
import { gql } from '@apollo/client'
import {hoprClient} from './QueryClients'
```

å®šä¹‰ç±»å’Œåˆå§‹çŠ¶æ€ã€‚

```
class HolderBalance extends React.Component {
  state = {
    loading: true,
    holderBalance: []
  }
```

é…ç½®æ‚¨è¦å‘é€çš„æŸ¥è¯¢ã€‚å°†`skip`ä¿ç•™ä¸ºå˜é‡ï¼Œå› ä¸ºæ‚¨éœ€è¦åœ¨è¿è¡Œæ—¶è°ƒæ•´å®ƒã€‚è¿™ä¸ªæŸ¥è¯¢æ„å‘³ç€æˆ‘ä»¬æƒ³è¦è·å¾—å¸æˆ·çš„ HOPR ä½™é¢ï¼Œå¹¶æ’é™¤é›¶åœ°å€(0x0)ã€‚

```
 async fetchData() {
    const holderBalanceQuery = `
 query accounts($skip: Int!) {
 accounts(where:{HoprBalance_gt:0, id_not:"0x0000000000000000000000000000000000000000"},first:1000, skip:$skip, orderBy: HoprBalance, orderDirection: desc)
 {
 totalBalance
 }
 }
 `
```

åœ¨ç»§ç»­ä¹‹å‰ï¼Œæ‚¨å¯èƒ½éœ€è¦æ£€æŸ¥åŸå§‹æ•°æ®ã€‚ä½¿ç”¨æ“åœºæ˜¯ä¸€ä¸ªä¸é”™çš„é€‰æ‹©ã€‚æ‚¨å¯ä»¥å¾ˆå®¹æ˜“åœ°æ‰¾åˆ°æ ¼å¼å’Œæ£€æŸ¥å€¼ã€‚

[![HOPR Subgraph Playground](img/db036745462b37586f3eff384e731603.png)](https://github.com/figment-networks/learn-tutorials/raw/master/assets/hopr-subgraph-playground.png)

ä½¿ç”¨ while å¾ªç¯å‘é€æŸ¥è¯¢ï¼Œç›´åˆ°ç»“æœå°‘äº 1000 æ¡è®°å½•ã€‚è¿™æ˜¯å› ä¸ºå•ä¸ªæŸ¥è¯¢æœ€å¤šåªèƒ½è¿”å› 1000 ä¸ªç»“æœã€‚ä¸ºäº†å¾—åˆ°æ‰€æœ‰æ•°æ®ï¼Œä½ éœ€è¦è°ƒæ•´`skip`å˜é‡ã€‚

```
    try {
      let skip = 0
      let allResults = []
      let found = false
      while (!found) {
        let result = await hoprClient.query({
          query: gql(holderBalanceQuery),
          variables: {
            skip: skip
          },
          fetchPolicy: 'cache-first',
        })
        allResults = allResults.concat(result.data.accounts)
        if (result.data.accounts.length < 1000) {
          found = true
        } else {
          skip += 1000
        }
      }

      return allResults
    } catch (e) {
      console.error(e)
    }
  }

  componentDidMount() {
    this.fetchData().then(data => {
      this.processHolderBalanceData(data)
    }).catch(e => {
      console.error(e)
    })
  }
```

ç°åœ¨ä½ æœ‰äº†åŸå§‹æ•°æ®ï¼Œæ¥ä¸‹æ¥çš„éƒ¨åˆ†æ˜¯å¯è§†åŒ–å®ƒã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æ ¹æ®å¸æˆ·çš„ HOPR ä»¤ç‰Œä½™é¢å°†å¸æˆ·åˆ†ä¸ºä¸åŒçš„ç±»åˆ«ã€‚

```
  processHolderBalanceData(data) {
    // Sizes are sorted in descending order
    const sizes = data.map(item => (parseFloat(item.totalBalance)))
    const spliters = [10, 100, 1000, 10000, 100000]
    // Find indexes spliting the sizes by given spliters
    let spliterIndex = spliters.length - 1
    let splitingIndexes = [0]
    for (let [idx, size] of sizes.entries()) {
      while (size <= spliters[spliterIndex]) {
        splitingIndexes.push(idx)
        spliterIndex -= 1
      }
      if (spliterIndex < 0 )
        break
    }
```

è¿™äº›ç±»åˆ«æ˜¯:

*   > 100k <g-emoji class="g-emoji" alias="whale" fallback-src="https://github.githubassets.cimg/icons/emoji/unicode/1f433.png">ğŸ³</g-emoji>
*   ' 10k-100k '
*   1k-10k '
*   100-1k '
*   '10-100'
*   '0-10'

æ‚¨éœ€è¦ä¸ºæ¯ä¸ªåˆ†ç±»çš„å—åˆ†é…åç§°ã€‚

```
    // Split sizes, get chunk size and calculate sum of each chunk
    const chunkNames = ['>100k ğŸ³', '10k-100k', '1k-10k', '100-1k', '10-100', '0-10']
    let splited = []
    for (let i = 0; i < splitingIndexes.length - 1; i++) {
      const chunk = sizes.slice(splitingIndexes[i], splitingIndexes[i + 1])
      splited.push({
        name: chunkNames[i],
        chunk: chunk
      })
    }
    splited.push({
      name: chunkNames[splitingIndexes.length - 1],
      chunk: sizes.slice(splitingIndexes[splitingIndexes.length - 1])
    })
    // Update holder balance data
    const reducer = (accumulator, currentValue) => accumulator + currentValue
    let holderBalance = splited.map((item) => {
      const length = item.chunk.length
      const noun = length === 1 ? 'holder' : 'holders'
      return ({
        name: `${item.name} (${length} ${noun})`,
        value: item.chunk.reduce(reducer)
      })
    })
    this.setState({
      loading: false,
      holderBalance: holderBalance
    })
  }
```

æœ€åï¼Œæ‚¨å¯ä»¥ç”Ÿæˆå›¾è¡¨å¹¶å°†å…¶å¯¼å‡ºã€‚å½“ app è¿˜åœ¨å–æ•°æ®æ—¶ï¼Œæ˜¾ç¤º`Loading...`ã€‚`state.loading`å˜æˆ`false`åï¼Œå±•ç¤ºæ–°é²œé¥¼çŠ¶å›¾ã€‚

```
  chart() {
    if (this.state.loading) {
      return <p>Loading...</p>
    }
    const options = {
      tooltip: {
          trigger: 'item',
          formatter: '{a} <br/>{b} : {c} ({d}%)'
      },
      series: [
        {
          name: 'Holder Balance',
          type: 'pie',
          radius: '50%',
          emphasis: {
            itemStyle: {
              shadowBlur: 10,
              shadowOffsetX: 0,
              shadowColor: 'rgba(0, 0, 0, 0.5)'
            }
          },
          data: this.state.holderBalance.map((item) => {
            return {
              ...item,
              value: parseFloat(item.value.toFixed(2))
            }
          }),
        }
      ]
    }
    return <ReactECharts option={options} />;
  }

  render() {
    return (
      <div>
        {this.chart()}
      </div>
    )
  }
}

export default HolderBalance
```

ç°åœ¨ï¼Œæ‚¨å¯ä»¥åœ¨åº”ç”¨ç¨‹åºä¸­æ˜¾ç¤ºæ–°å›¾è¡¨äº†ã€‚åªéœ€ç”¨ä»¥ä¸‹ä»£ç æ›¿æ¢ App.js ä¸­çš„ä»£ç :

```
import './App.css';
import HolderBalance from './HolderBalance'

function App() {
  return (
    <div className="App">
      <HolderBalance />
    </div>
  );
}

export default App;
```

è¯·è®°ä½ä¿å­˜å¯¹ä»£ç çš„æ‰€æœ‰æ›´æ”¹ï¼Œç„¶ååˆ·æ–° localhost é¡µé¢ã€‚æ‚¨åº”è¯¥ä¼šçœ‹åˆ°æˆ‘ä»¬åˆšåˆšåˆ›å»ºçš„æ¼‚äº®çš„é¥¼å›¾:

[![Graph React App Pie Chart](img/e423edfd5e00c2e066f0f071b1e6fac0.png)](https://github.com/figment-networks/learn-tutorials/raw/master/assets/graph-react-app-pie-chart.png)

# ç»“è®º

æ­å–œä½ ï¼Œä½ å·²ç»å®Œæˆäº†æ•™ç¨‹ï¼æ‚¨å·²ç»å­¦ä¹ äº†å¦‚ä½•é…ç½® GraphQL æŸ¥è¯¢æ¥ä»ç°æœ‰çš„å­å›¾ä¸­æ£€ç´¢æ•°æ®ã€‚æ‚¨è¿˜äº†è§£å¦‚ä½•åœ¨ React åº”ç”¨ç¨‹åºä¸­æ­£ç¡®åœ°å¯è§†åŒ–æ•°æ®ã€‚

# å…³äºä½œè€…

æœ¬æ•™ç¨‹æ˜¯ç”±ç±³å¥ˆç‰¹åŸºé‡‘åˆ›å»ºçš„ï¼Œè¿™æ˜¯ä¸€ä¸ªæ´»è·ƒçš„ç»„ç»‡ï¼Œä»¥éªŒè¯è€…çš„èº«ä»½å¸®åŠ©åˆå¹¶åŒºå—é“¾çš„é¡¹ç›®ã€‚æˆ‘ä»¬æ­£åœ¨ç§¯ææ„å»ºå’Œåˆ©ç”¨å­å›¾ã€‚å¦‚æœæ‚¨æœ‰ä»»ä½•é—®é¢˜ï¼Œè¯·éšæ—¶é€šè¿‡ä»¥ä¸‹æ–¹å¼è”ç³»æˆ‘ä»¬:

*   ä¸å’Œ:minatofund#1944
*   æ¨ç‰¹: [@FundMinato](https://twitter.com/FundMinato)